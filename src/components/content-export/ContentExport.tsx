import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import CodeBlock from './CodeBlock';

export default function ContentExport() {
  return (
    <Dialog>
      <DialogTrigger className='flex text-md bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2 items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0'>
        Export
      </DialogTrigger>
      <DialogContent className='overflow-hidden'>
        <DialogHeader className='gap-4'>
          <DialogTitle>Content Export</DialogTitle>
          <DialogDescription>
            Export the content in markdown format or json response format
          </DialogDescription>
        </DialogHeader>
        <CodeBlock>
          {
            "JavaScript is a versatile language, widely used for both front-end and back-end development. As a JavaScript developer, mastering algorithms and data structures is crucial for solving problems efficiently and writing optimized code. While frameworks and libraries like React and Node.js are great tools, understanding the underlying concepts can help you become a much better developer. \n\nIn this blog post, we’ll explore some essential algorithms and data structures you should master as a JavaScript developer, including their use cases, implementation, and real-world applications. \n\n---\n\n## Why Algorithms and Data Structures Matter\n\nBefore diving into specific algorithms and data structures, it’s important to understand why they are so crucial:\n\n- **Efficiency**: The right data structure and algorithm can drastically improve the performance of your application, making it faster and more responsive.\n- **Problem-Solving**: Many coding challenges and real-world problems require you to choose the correct algorithm or data structure to solve them efficiently.\n- **Interview Preparation**: Tech interviews often test your understanding of data structures and algorithms. Knowing them will give you an edge in securing a job.\n\n---\n\n## Must-Know Data Structures for JavaScript Developers\n\nLet’s start with some basic and advanced data structures that you should be familiar with. \n\n### 1. Arrays\n\nArrays are one of the most fundamental data structures, and they are widely used in JavaScript for storing ordered collections of elements. Arrays in JavaScript are dynamic and can hold multiple data types.\n\n#### Example:\n\n```javascript\nlet numbers = [1, 2, 3, 4, 5];\nnumbers.push(6); // Add an element at the end\nnumbers.shift(); // Remove the first element\nconsole.log(numbers); // Output: [2, 3, 4, 5, 6]\n```\n\n### 2. Linked Lists\n\nA linked list is a linear data structure where each element (node) contains data and a reference to the next node in the sequence. Unlike arrays, linked lists allow efficient insertion and deletion of elements.\n\n#### Types of Linked Lists:\n- **Singly Linked List**: Each node points to the next node.\n- **Doubly Linked List**: Each node points to both the next and previous node.\n\n#### Example (Singly Linked List):\n\n```javascript\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  insert(data) {\n    let newNode = new Node(data);\n    newNode.next = this.head;\n    this.head = newNode;\n  }\n\n  printList() {\n    let current = this.head;\n    while (current !== null) {\n      console.log(current.data);\n      current = current.next;\n    }\n  }\n}\n\nlet list = new LinkedList();\nlist.insert(10);\nlist.insert(20);\nlist.printList(); // Output: 20, 10\n```\n\n### 3. Stacks\n\nA stack is a data structure that follows the **Last In, First Out (LIFO)** principle. Elements are added and removed from the top of the stack.\n\n#### Example:\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\nlet stack = new Stack();\nstack.push(1);\nstack.push(2);\nconsole.log(stack.pop()); // Output: 2\nconsole.log(stack.peek()); // Output: 1\n```\n\n### 4. Queues\n\nA queue is a **First In, First Out (FIFO)** data structure. Elements are added at the end and removed from the front.\n\n#### Example:\n\n```javascript\nclass Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    return this.items.shift();\n  }\n\n  peek() {\n    return this.items[0];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\nlet queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nconsole.log(queue.dequeue()); // Output: 1\n```\n\n### 5. Hash Tables (Objects in JS)\n\nHash tables (or hash maps) are key-value stores that offer efficient insertion, deletion, and search operations. In JavaScript, you can use objects or the `Map` data structure for this purpose.\n\n#### Example:\n\n```javascript\nlet hashTable = {};\nhashTable['name'] = 'John';\nhashTable['age'] = 30;\n\nconsole.log(hashTable['name']); // Output: John\n```\n\n---\n\n## Essential Algorithms to Master\n\nNow that we've covered the data structures, let's dive into some essential algorithms. Algorithms are the heart of problem-solving in coding. Below are some that every JavaScript developer should be familiar with.\n\n### 1. Sorting Algorithms\n\nSorting is a common operation where you need to order a collection of elements. Some popular sorting algorithms include:\n\n- **Bubble Sort**\n- **Selection Sort**\n- **Insertion Sort**\n- **Merge Sort**\n- **Quick Sort**\n\n#### Example (Bubble Sort):\n\n```javascript\nfunction bubbleSort(arr) {\n  let n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - 1 - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Swap elements\n      }\n    }\n  }\n  return arr;\n}\n\nconsole.log(bubbleSort([5, 3, 8, 4, 2])); // Output: [2, 3, 4, 5, 8]\n```\n\n### 2. Searching Algorithms\n\nSearching is another fundamental operation. You may need to find an element in a collection. Some common searching algorithms include:\n\n- **Linear Search**\n- **Binary Search**\n\n#### Example (Binary Search):\n\n```javascript\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    }\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n\nconsole.log(binarySearch([1, 2, 3, 4, 5, 6], 4)); // Output: 3\n```\n\n### 3. Recursion\n\nRecursion is when a function calls itself to solve a problem. It's useful for solving problems that can be broken down into smaller sub-problems, like tree traversals and factorial calculations.\n\n#### Example (Factorial Calculation):\n\n```javascript\nfunction factorial(n) {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // Output: 120\n```\n\n### 4. Dynamic Programming\n\nDynamic programming is a technique used to solve problems by breaking them down into simpler sub-problems and storing the results to avoid redundant calculations.\n\n#### Example (Fibonacci Sequence):\n\n```javascript\nfunction fibonacci(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n\n  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n  return memo[n];\n}\n\nconsole.log(fibonacci(10)); // Output: 55\n```\n\n---\n\n## Final Thoughts\n\nMastering data structures and algorithms is key to becoming a proficient JavaScript developer. Whether you’re working on small web apps or large-scale enterprise applications, understanding the right data structure to use and the best algorithm to solve a problem will make your code more efficient, readable, and maintainable.\n\nKeep practicing by solving coding challenges and building projects, as applying these concepts in real-world scenarios is the best way to solidify your knowledge.\n\n---\n\n## Additional Resources\n\nIf you're looking to dive deeper, here are some great resources to continue your learning:\n\n \n- [JavaScript Algorithms and Data Structures](https://www.freecodecamp.org/learn/coding-interview-prep/data-structures/)\n- [LeetCode](https://leetcode.com/)\n"
          }
        </CodeBlock>
      </DialogContent>
    </Dialog>
  );
}
